# Statements and Messages Architecture

## Overview

KePrompt uses a three-layer architecture to manage conversational AI interactions:

1. **Statements** - Source code layer (executable instructions)
2. **Messages (Universal Format)** - Data layer (provider-agnostic)
3. **Messages (Company Format)** - API layer (provider-specific, ephemeral)

## Layer 1: Statements (Source Code)

Statements are the executable instructions stored in `.prompt` files and maintained in the VM's execution state.

### Characteristics
- Stored in `vm.statements[]` list
- Each statement has: `msg_no` (line number), `keyword` (command), `value` (content)
- Executed sequentially using the IP (instruction pointer)
- Serialized to database as `statements_json`
- Can be added dynamically during chat updates

### Statement-to-Message Mapping

| Statement | Creates Message | Role | Content Type |
|-----------|----------------|------|--------------|
| `.user` | AiMessage | user | AiTextPart |
| `.system` | AiMessage | system | AiTextPart |
| `.assistant` | AiMessage | assistant | AiTextPart |
| `.image` | AiMessage | user | AiImagePart |
| `.tool_call` | AiMessage | assistant | AiCall |
| `.tool_result` | AiMessage | tool | AiResult |
| `.exec` | AiMessage | assistant | Mixed (text + calls) |
| `.cmd` | Appends to current message | - | AiTextPart |

### Example Statement Execution
```
.prompt "name":"Example", "version":"1.0.0"
.user "Hello, AI!"
.exec
.exit
```

Execution flow:
1. VM parses statements from `.prompt` file
2. IP starts at 0
3. Each statement's `execute()` method is called
4. Statements create/modify messages
5. IP advances until `.exit`

## Layer 2: Messages (Universal Format)

Messages represent the conversation history in a provider-agnostic format.

### Characteristics
- Stored in `vm.prompt.messages[]` list
- Each message has: `role` (user/assistant/system/tool), `content` (list of parts)
- Serialized to database as `messages_json`
- Maintained across chat updates
- Can contain multiple content parts

### Message Content Types

#### AiTextPart
```python
AiTextPart(vm=vm, text="Hello, world!")
```
Plain text content.

#### AiImagePart
```python
AiImagePart(vm=vm, filename="image.png")
```
Base64-encoded image data.

#### AiCall (Tool/Function Call)
```python
AiCall(vm=vm, name="readfile", 
       arguments={"filename": "data.txt"}, 
       id="call_abc123")
```
Represents LLM requesting tool execution.

#### AiResult (Tool/Function Result)
```python
AiResult(vm=vm, name="readfile", 
         id="call_abc123", 
         result="File contents...")
```
Represents tool execution results sent back to LLM.

### Message Structure Example
```python
[
    AiMessage(role='user', content=[
        AiTextPart(text='Read file data.txt')
    ]),
    AiMessage(role='assistant', content=[
        AiCall(name='readfile', arguments={'filename': 'data.txt'}, id='call_001')
    ]),
    AiMessage(role='tool', content=[
        AiResult(name='readfile', id='call_001', result='File contents: ...')
    ]),
    AiMessage(role='assistant', content=[
        AiTextPart(text='The file contains...')
    ])
]
```

## Layer 3: Messages (Company Format)

Provider-specific message format used for API calls.

### Characteristics
- Generated by `provider.to_company_messages()` at START of each `call_llm()`
- Converted back by `provider.to_ai_message()` at END of each call
- **NOT stored** - ephemeral, generated on-demand
- Provider-specific (OpenAI, Anthropic, Google, etc.)

### Conversion Flow
```
Universal Format → Company Format → API Call → Company Response → Universal Format
```

Example:
```python
# Before API call
company_msgs = provider.to_company_messages(vm.prompt.messages)

# After API call
response_msg = provider.to_ai_message(api_response)
vm.prompt.messages.append(response_msg)
```

## Complete Round-Trip Example

### Initial .prompt File
```
.prompt "name":"FileReader", "version":"1.0.0"
.user "Read data.txt"
.exec
.exit
```

### Execution Steps

1. **Parse Statements**
```python
vm.statements = [
    StmtPromptMeta(keyword='.prompt', value='...'),
    StmtUser(keyword='.user', value='Read data.txt'),
    StmtExec(keyword='.exec', value=''),
    StmtExit(keyword='.exit', value='')
]
```

2. **Execute .user Statement**
```python
# StmtUser.execute() creates:
vm.prompt.messages = [
    AiMessage(role='user', content=[
        AiTextPart(text='Read data.txt')
    ])
]
```

3. **Execute .exec Statement**
```python
# Convert to company format
company_msgs = provider.to_company_messages(vm.prompt.messages)

# Make API call (returns tool call)
response = api_call(company_msgs)

# Convert back to universal format
response_msg = provider.to_ai_message(response)
# response_msg = AiMessage(role='assistant', content=[
#     AiCall(name='readfile', arguments={'filename': 'data.txt'}, id='call_001')
# ])

vm.prompt.messages.append(response_msg)
```

4. **Execute Tool Call** (automatic in call_llm)
```python
# Execute function
result = FunctionSpace.functions.call('readfile', {'filename': 'data.txt'})

# Create tool result message
tool_msg = AiMessage(role='tool', content=[
    AiResult(name='readfile', id='call_001', result=result)
])
vm.prompt.messages.append(tool_msg)
```

5. **Final API Call**
```python
# Convert updated messages to company format
company_msgs = provider.to_company_messages(vm.prompt.messages)

# Make final API call
response = api_call(company_msgs)

# Convert response
final_msg = provider.to_ai_message(response)
# final_msg = AiMessage(role='assistant', content=[
#     AiTextPart(text='The file contains: ...')
# ])

vm.prompt.messages.append(final_msg)
```

6. **Serialize for Storage**
```python
# Statements
statements_json = json.dumps(vm.serialize_statements())

# Messages (universal format only)
messages_json = json.dumps(vm.prompt.to_json())

# Save to database
db_manager.save_chat(
    chat_id=vm.prompt_uuid,
    statements_json=statements_json,
    messages_json=messages_json
)
```

## Chat Update Flow

When continuing a chat:

```python
# 1. Load VM from database
vm = chat_manager.load_vm(chat_id)
# Restores: vm.statements[] and vm.prompt.messages[]

# 2. Add new statements
vm.add_statement(keyword=".user", value="Follow-up question")
vm.add_statement(keyword=".exec", value='')

# 3. Execute from current IP
vm.execute()
# IP continues from where it left off
# New statements create new messages

# 4. Save updated state
chat_manager.save_chat(vm)
# Both statements and messages are saved
```

## New Statement Types for Complete Coverage

### .tool_call - Recreate Tool Calls

Used for manually recreating conversation with tool calls (debugging, testing).

**Syntax:**
```
.tool_call function_name(param1=value1, param2=value2) id=call_id
```

**Example:**
```
.tool_call readfile(filename="data.txt") id=call_abc123
```

**Creates:**
```python
AiMessage(role='assistant', content=[
    AiCall(name='readfile', arguments={'filename': 'data.txt'}, id='call_abc123')
])
```

### .tool_result - Recreate Tool Results

Used for manually recreating function execution results.

**Syntax:**
```
.tool_result id=call_id name=function_name
result content (can be multi-line)
```

**Example:**
```
.tool_result id=call_abc123 name=readfile
File contents: Lorem ipsum dolor sit amet...
```

**Creates:**
```python
AiMessage(role='tool', content=[
    AiResult(name='readfile', id='call_abc123', result='File contents: Lorem...')
])
```

## Complete Statement-Message Symmetry

With the new statement types, **every message type can now be represented as a statement**:

| Message Type | Statement | Use Case |
|--------------|-----------|----------|
| user + text | `.user` | User input |
| system + text | `.system` | System instructions |
| assistant + text | `.assistant` | Direct assistant text |
| assistant + call | `.tool_call` | Manual tool call creation |
| tool + result | `.tool_result` | Manual result creation |
| user + image | `.image` | Image input |

This enables:
1. **Complete conversation reconstruction** from statements
2. **Manual conversation editing** for testing
3. **Conversation debugging** with exact replay
4. **Statement-only storage** (messages can be regenerated)

## Database Schema

### Chats Table
```python
chat_id: str              # Primary key
statements_json: str      # Serialized statements
messages_json: str        # Serialized messages (universal format)
vm_state_json: str        # VM execution state
variables_json: str       # Variable dictionary
```

### Why Store Both?

**Statements:**
- Source code representation
- Shows what was executed
- Can be modified and re-executed
- Compact representation

**Messages:**
- Conversation history
- Shows actual exchange
- Contains LLM responses
- Complete data (including tool results)

**Together:**
- Statements = How we got here
- Messages = What actually happened
- Both needed for complete conversation management

## Best Practices

### For .prompt Files
- Use statements for structure and logic
- Let `.exec` generate assistant responses
- Use `.cmd` for function execution during prompts

### For Chat Replay
- Load statements from database
- Deserialize and re-execute
- Messages are regenerated through execution

### For Debugging
- Use `.tool_call` and `.tool_result` to manually create conversations
- Test function handling without LLM calls
- Verify provider format conversions

### For Storage
- Always save both statements and messages
- Statements enable re-execution
- Messages preserve exact responses
- Together they provide complete audit trail

## Future Enhancements

1. **Statement-only mode**: Regenerate messages from statements on load
2. **Conversation diffing**: Compare statement vs message history
3. **Selective replay**: Re-execute specific statement ranges
4. **Statement editing**: Modify and branch conversations
5. **Message validation**: Ensure statement-message consistency

## Summary

The three-layer architecture provides:
- **Separation of concerns**: Source (statements) vs Data (messages) vs API (company format)
- **Provider independence**: Universal format works with any LLM
- **Complete audit trail**: Know what was executed and what happened
- **Flexibility**: Modify conversations at any level
- **Reliability**: Round-trip serialization maintains fidelity

This architecture is the foundation for advanced features like conversation editing, branching, replay, and multi-provider support.
